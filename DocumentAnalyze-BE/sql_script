-- Table: public.document_texts

-- DROP TABLE IF EXISTS public.document_texts;

CREATE TABLE IF NOT EXISTS public.document_texts
(
    id integer NOT NULL DEFAULT nextval('document_texts_id_seq'::regclass),
    document_id integer,
    extracted_text text COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT document_texts_pkey PRIMARY KEY (id),
    CONSTRAINT document_texts_document_id_fkey FOREIGN KEY (document_id)
        REFERENCES public.documents (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.document_texts
    OWNER to postgres;

-- Table: public.documents

-- DROP TABLE IF EXISTS public.documents;

CREATE TABLE IF NOT EXISTS public.documents
(
    id integer NOT NULL DEFAULT nextval('documents_id_seq'::regclass),
    filename text COLLATE pg_catalog."default" NOT NULL,
    storage_path text COLLATE pg_catalog."default" NOT NULL,
    uploaded_by integer,
    upload_time timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    document_type text COLLATE pg_catalog."default",
    status character varying(50) COLLATE pg_catalog."default" DEFAULT 'pending'::text,
    language text COLLATE pg_catalog."default",
    CONSTRAINT documents_pkey PRIMARY KEY (id),
    CONSTRAINT documents_uploaded_by_fkey FOREIGN KEY (uploaded_by)
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE SET NULL,
    CONSTRAINT documents_status_check CHECK (status::text = ANY (ARRAY['processed'::character varying, 'classified'::character varying, 'review_needed'::character varying, 'routed'::character varying]::text[]))
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.documents
    OWNER to postgres;

-- Table: public.errors

-- DROP TABLE IF EXISTS public.errors;

CREATE TABLE IF NOT EXISTS public.errors
(
    id integer NOT NULL DEFAULT nextval('errors_id_seq'::regclass),
    document_id integer,
    error_message text COLLATE pg_catalog."default" NOT NULL,
    "timestamp" timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    resolved boolean DEFAULT false,
    CONSTRAINT errors_pkey PRIMARY KEY (id),
    CONSTRAINT errors_document_id_fkey FOREIGN KEY (document_id)
        REFERENCES public.documents (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.errors
    OWNER to postgres;

-- Table: public.logs

-- DROP TABLE IF EXISTS public.logs;

CREATE TABLE IF NOT EXISTS public.logs
(
    id integer NOT NULL DEFAULT nextval('logs_id_seq'::regclass),
    event_type character varying(50) COLLATE pg_catalog."default" NOT NULL,
    message text COLLATE pg_catalog."default" NOT NULL,
    "timestamp" timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    source text COLLATE pg_catalog."default",
    user_id integer,
    document_id integer,
    CONSTRAINT logs_pkey PRIMARY KEY (id),
    CONSTRAINT logs_document_id_fkey FOREIGN KEY (document_id)
        REFERENCES public.documents (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE SET NULL,
    CONSTRAINT logs_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES public.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT logs_event_type_check CHECK (event_type::text = ANY (ARRAY['ERROR'::text, 'INFO'::text, 'WARNING'::text]))
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.logs
    OWNER to postgres;

-- Table: public.processing_stages

-- DROP TABLE IF EXISTS public.processing_stages;

CREATE TABLE IF NOT EXISTS public.processing_stages
(
    id integer NOT NULL DEFAULT nextval('processing_stages_id_seq'::regclass),
    document_id integer NOT NULL,
    stage character varying(50) COLLATE pg_catalog."default" NOT NULL,
    duration double precision,
    details text COLLATE pg_catalog."default",
    CONSTRAINT processing_stages_pkey PRIMARY KEY (id),
    CONSTRAINT processing_stages_document_id_fkey FOREIGN KEY (document_id)
        REFERENCES public.documents (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.processing_stages
    OWNER to postgres;

-- Table: public.routing

-- DROP TABLE IF EXISTS public.routing;

CREATE TABLE IF NOT EXISTS public.routing
(
    id integer NOT NULL DEFAULT nextval('routing_id_seq'::regclass),
    document_id integer NOT NULL,
    routed_to character varying(100) COLLATE pg_catalog."default" NOT NULL,
    "timestamp" timestamp without time zone,
    reason text COLLATE pg_catalog."default",
    CONSTRAINT routing_pkey PRIMARY KEY (id),
    CONSTRAINT routing_document_id_fkey FOREIGN KEY (document_id)
        REFERENCES public.documents (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.routing
    OWNER to postgres;

    -- Table: public.users

-- DROP TABLE IF EXISTS public.users;

CREATE TABLE IF NOT EXISTS public.users
(
    id integer NOT NULL DEFAULT nextval('users_id_seq'::regclass),
    username character varying(255) COLLATE pg_catalog."default" NOT NULL,
    password_hash text COLLATE pg_catalog."default" NOT NULL,
    email character varying(255) COLLATE pg_catalog."default",
    role character varying(50) COLLATE pg_catalog."default" DEFAULT 'user'::character varying,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT users_pkey PRIMARY KEY (id),
    CONSTRAINT users_email_key UNIQUE (email),
    CONSTRAINT users_username_key UNIQUE (username)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.users
    OWNER to postgres;